{"version":3,"sources":["Scheduler.js"],"names":[],"mappings":"AAAA,a;AACA,+B;;AAEM,S;AACJ,c,GAAa,IAAI,gBAAI,SAAJ,CAAc,MAAlB,E;AACb,S,GAAQ,C;AACR,qB,GAAoB,IAAI,gBAAI,MAAR,CAAe,KAAK,SAApB,C;;AAEhB,S,EAAyB,KAAlB,WAAkB,yDAAN,IAAM;AAC3B,WAAK,UAAL,CAAgB,GAAhB,CAAoB,KAApB,EAA2B,WAA3B,EACD,C;;;AAEM,S,EAAO;AACZ,WAAK,UAAL,CAAgB,MAAhB,CAAuB,KAAvB,EACD,C;;;AAEM;AACL,WAAK,KAAL,GACD,C;;;AAEQ;AACP,UAAI,CAAC,KAAK,KAAV,EAAiB,CAAE,MAAM,IAAI,KAAJ,CAAU,+BAAV,CAAN,CAAmD;AACtE,WAAK,KAAL;;AAEA,aAAO,CAAC,KAAK,KAAb,EAAoB;AAClB,YAAM,QAAQ,KAAK,UAAL,CAAgB,IAAhB,EAAd;AACA,YAAI,CAAC,KAAL,EAAY,CAAE,OAAO,KAAK,IAAL,EAAP,CAAqB,C;AACnC,YAAM,SAAS,MAAM,GAAN,EAAf;AACA,YAAI,UAAU,OAAO,IAArB,EAA2B,C;AACzB,eAAK,IAAL;AACA,iBAAO,IAAP,CAAY,KAAK,MAAL,CAAY,IAAZ,CAAiB,IAAjB,CAAZ,EACD,CACF,CACF,C;;;;;;AAGY,S;;;;;AAKf,gBAAI,MAAJ,GAAa,UAAS,SAAT,EAAoB;AAC/B,OAAK,UAAL,GAAkB,SAAlB;AACA,OAAK,KAAL,GAAa,CAAb,CACD,CAHD;;;;;;AAQA,gBAAI,MAAJ,CAAW,SAAX,CAAqB,KAArB,GAA6B,YAAW;AACtC,SAAO,KAAK,MAAL,EAAP,CACD,CAFD;;;;;;AAOA,gBAAI,MAAJ,CAAW,SAAX,CAAqB,IAArB,GAA4B,YAAW;AACrC,OAAK,KAAL;AACA,SAAO,IAAP,CACD,CAHD;;;;;;AAQA,gBAAI,MAAJ,CAAW,SAAX,CAAqB,MAArB,GAA8B,YAAW;AACvC,MAAI,CAAC,KAAK,KAAV,EAAiB,CAAE,MAAM,IAAI,KAAJ,CAAU,+BAAV,CAAN,CAAmD;AACtE,OAAK,KAAL;;AAEA,SAAO,CAAC,KAAK,KAAb,EAAoB;AAClB,QAAI,QAAQ,KAAK,UAAL,CAAgB,IAAhB,EAAZ;AACA,QAAI,CAAC,KAAL,EAAY,CAAE,OAAO,KAAK,IAAL,EAAP,CAAqB,C;AACnC,QAAI,SAAS,MAAM,GAAN,EAAb;AACA,QAAI,UAAU,OAAO,IAArB,EAA2B,C;AACzB,WAAK,IAAL;AACA,aAAO,IAAP,CAAY,KAAK,MAAL,CAAY,IAAZ,CAAiB,IAAjB,CAAZ,EACD,CACF;;;;AAED,SAAO,IAAP,CACD,CAfD","file":"Scheduler.js","sourcesContent":["'use strict';\r\nimport ROT from 'rot-js';\r\n\r\nclass Scheduler {\r\n  _scheduler = new ROT.Scheduler.Action();\r\n  _lock = 1;\r\n  _schedulingEngine = new ROT.Engine(this.scheduler);\r\n\r\n  add(actor, isRecurring=true) {\r\n    this._scheduler.add(actor, isRecurring);\r\n  }\r\n  \r\n  remove(actor) {\r\n    this._scheduler.remove(actor);\r\n  }\r\n\r\n  lock() {\r\n    this._lock++;\r\n  }\r\n\r\n  unlock() {\r\n    if (!this._lock) { throw new Error(\"Cannot unlock unlocked engine\"); }\r\n    this._lock--;\r\n\r\n    while (!this._lock) {\r\n      const actor = this._scheduler.next();\r\n      if (!actor) { return this.lock(); } /* no actors */\r\n      const result = actor.act();\r\n      if (result && result.then) { /* actor returned a \"thenable\", looks like a Promise */\r\n        this.lock();\r\n        result.then(this.unlock.bind(this));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Scheduler;\r\n/**\r\n * @class Asynchronous main loop\r\n * @param {ROT.Scheduler} scheduler\r\n */\r\nROT.Engine = function(scheduler) {\r\n  this._scheduler = scheduler;\r\n  this._lock = 1;\r\n}\r\n\r\n/**\r\n * Start the main loop. When this call returns, the loop is locked.\r\n */\r\nROT.Engine.prototype.start = function() {\r\n  return this.unlock();\r\n}\r\n\r\n/**\r\n * Interrupt the engine by an asynchronous action\r\n */\r\nROT.Engine.prototype.lock = function() {\r\n  this._lock++;\r\n  return this;\r\n}\r\n\r\n/**\r\n * Resume execution (paused by a previous lock)\r\n */\r\nROT.Engine.prototype.unlock = function() {\r\n  if (!this._lock) { throw new Error(\"Cannot unlock unlocked engine\"); }\r\n  this._lock--;\r\n\r\n  while (!this._lock) {\r\n    var actor = this._scheduler.next();\r\n    if (!actor) { return this.lock(); } /* no actors */\r\n    var result = actor.act();\r\n    if (result && result.then) { /* actor returned a \"thenable\", looks like a Promise */\r\n      this.lock();\r\n      result.then(this.unlock.bind(this));\r\n    }\r\n  }\r\n\r\n  return this;\r\n}\r\n"],"sourceRoot":"/source/"}